-- Migration: Trust & Safety Legal Escalation System
-- Purpose: Add tables for legal escalation tickets and enforcement action audit trail
-- Author: Implementation Plan Phase 1.2.2
-- Date: 2025-09-16

BEGIN;

-- ✅ EXPERT RECOMMENDATION: Removed session_replication_role = 'replica'
-- This was disabling all triggers and RLS during migration unnecessarily

-- =====================================================
-- Legal Escalation Tickets Table
-- =====================================================

CREATE TABLE IF NOT EXISTS legal_escalation_tickets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  ticket_id VARCHAR(100) UNIQUE NOT NULL, -- Format: legal-{userId}-{timestamp}
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  violation_code VARCHAR(10) NOT NULL, -- T01-T05
  evidence JSONB NOT NULL DEFAULT '[]',
  priority VARCHAR(20) NOT NULL CHECK (priority IN ('low', 'medium', 'high', 'critical')),
  assignee VARCHAR(255) NOT NULL,
  status VARCHAR(50) NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'in_progress', 'resolved', 'closed')),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  resolved_at TIMESTAMP WITH TIME ZONE,
  resolution_notes TEXT,

  -- Add constraints
  CONSTRAINT legal_tickets_evidence_is_array CHECK (jsonb_typeof(evidence) = 'array')
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_legal_tickets_user_id ON legal_escalation_tickets(user_id);
CREATE INDEX IF NOT EXISTS idx_legal_tickets_violation_code ON legal_escalation_tickets(violation_code);
CREATE INDEX IF NOT EXISTS idx_legal_tickets_priority ON legal_escalation_tickets(priority);
CREATE INDEX IF NOT EXISTS idx_legal_tickets_status ON legal_escalation_tickets(status);
CREATE INDEX IF NOT EXISTS idx_legal_tickets_created_at ON legal_escalation_tickets(created_at DESC);

-- =====================================================
-- Trust & Safety Enforcement Actions Audit Table
-- =====================================================

CREATE TABLE IF NOT EXISTS trust_safety_actions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  action VARCHAR(100) NOT NULL, -- payment_freeze, payment_unfreeze, legal_escalation, etc.
  reason TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  performed_by VARCHAR(255), -- Admin user or system
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),

  -- Add constraint for metadata
  CONSTRAINT trust_actions_metadata_is_object CHECK (jsonb_typeof(metadata) = 'object')
);

-- Create indexes for audit queries
CREATE INDEX IF NOT EXISTS idx_trust_actions_user_id ON trust_safety_actions(user_id);
CREATE INDEX IF NOT EXISTS idx_trust_actions_action ON trust_safety_actions(action);
CREATE INDEX IF NOT EXISTS idx_trust_actions_created_at ON trust_safety_actions(created_at DESC);

-- =====================================================
-- Add payment blocking fields to user_admin_status table
-- =====================================================

DO $$
BEGIN
  -- Add payments_blocked fields if they don't exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'payments_blocked') THEN
    ALTER TABLE user_admin_status ADD COLUMN payments_blocked BOOLEAN NOT NULL DEFAULT FALSE;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'payments_blocked_reason') THEN
    ALTER TABLE user_admin_status ADD COLUMN payments_blocked_reason TEXT;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'payments_blocked_at') THEN
    ALTER TABLE user_admin_status ADD COLUMN payments_blocked_at TIMESTAMP WITH TIME ZONE;
  END IF;
END $$;

-- =====================================================
-- Add MFA enforcement fields to user_admin_status table
-- =====================================================

DO $$
BEGIN
  -- Add MFA requirement fields if they don't exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'mfa_required') THEN
    ALTER TABLE user_admin_status ADD COLUMN mfa_required BOOLEAN NOT NULL DEFAULT FALSE;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'mfa_enabled') THEN
    ALTER TABLE user_admin_status ADD COLUMN mfa_enabled BOOLEAN NOT NULL DEFAULT FALSE;
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'mfa_grace_expires_at') THEN
    ALTER TABLE user_admin_status ADD COLUMN mfa_grace_expires_at TIMESTAMP WITH TIME ZONE;
  END IF;
END $$;

-- Create indexes for payment blocking and MFA queries on user_admin_status
CREATE INDEX IF NOT EXISTS idx_user_admin_status_payments_blocked ON user_admin_status(payments_blocked, user_id);
CREATE INDEX IF NOT EXISTS idx_user_admin_status_mfa_required ON user_admin_status(mfa_required, mfa_enabled, user_id);
CREATE INDEX IF NOT EXISTS idx_user_admin_status_mfa_grace_expires ON user_admin_status(mfa_grace_expires_at) WHERE mfa_grace_expires_at IS NOT NULL;

-- =====================================================
-- Composite Indexes for Common Query Patterns (Expert Recommendation)
-- =====================================================

-- Tickets by user & status (most common admin query)
CREATE INDEX IF NOT EXISTS idx_legal_tickets_user_status_created
  ON legal_escalation_tickets (user_id, status, created_at DESC);

-- Tickets by status & priority (admin dashboard filtering)
CREATE INDEX IF NOT EXISTS idx_legal_tickets_status_priority_created
  ON legal_escalation_tickets (status, priority, created_at DESC);

-- JSONB evidence search support (if searching inside evidence)
CREATE INDEX IF NOT EXISTS idx_legal_tickets_evidence_gin
  ON legal_escalation_tickets USING GIN (evidence jsonb_path_ops);

-- Trust actions by user and action type (audit queries)
CREATE INDEX IF NOT EXISTS idx_trust_actions_user_action_created
  ON trust_safety_actions (user_id, action, created_at DESC);

-- =====================================================
-- Add pause tracking fields to billing_subscriptions table
-- =====================================================

DO $$
BEGIN
  -- Add pause tracking fields if they don't exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'billing_subscriptions' AND column_name = 'pause_reason') THEN
    ALTER TABLE billing_subscriptions ADD COLUMN pause_reason VARCHAR(100);
  END IF;

  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'billing_subscriptions' AND column_name = 'paused_at') THEN
    ALTER TABLE billing_subscriptions ADD COLUMN paused_at TIMESTAMP WITH TIME ZONE;
  END IF;

  -- Add cancel tracking fields for billing_payments table if it exists
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'billing_payments') THEN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                   WHERE table_name = 'billing_payments' AND column_name = 'cancel_reason') THEN
      ALTER TABLE billing_payments ADD COLUMN cancel_reason VARCHAR(100);
    END IF;

    IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                   WHERE table_name = 'billing_payments' AND column_name = 'canceled_at') THEN
      ALTER TABLE billing_payments ADD COLUMN canceled_at TIMESTAMP WITH TIME ZONE;
    END IF;
  END IF;
END $$;

-- =====================================================
-- ENUMs for Type Safety (Expert Recommendation)
-- =====================================================

-- Create ENUMs to prevent typos and data drift
DO $$
BEGIN
  CREATE TYPE legal_ticket_status AS ENUM ('open','in_progress','resolved','closed');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  CREATE TYPE legal_ticket_priority AS ENUM ('low','medium','high','critical');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

DO $$
BEGIN
  CREATE TYPE violation_code_t AS ENUM ('T01','T02','T03','T04','T05');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END $$;

-- =====================================================
-- DB-Generated Ticket IDs (Expert Recommendation)
-- =====================================================

-- Enable pgcrypto for better ID generation
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Temporarily drop NOT NULL to allow trigger-based generation during creation
-- Will be restored after trigger is set up
ALTER TABLE legal_escalation_tickets
  ALTER COLUMN ticket_id DROP NOT NULL;

-- Function to generate consistent ticket IDs
CREATE OR REPLACE FUNCTION gen_legal_ticket_id(uid uuid)
RETURNS text LANGUAGE sql IMMUTABLE AS $$
  SELECT 'legal-' || replace(uid::text, '-', '') || '-' || to_char(NOW(), 'YYYYMMDDHH24MISSMS')
$$;

-- Trigger to auto-generate ticket_id if not provided
CREATE OR REPLACE FUNCTION set_ticket_id_default()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.ticket_id IS NULL THEN
    NEW.ticket_id := gen_legal_ticket_id(NEW.user_id);
  END IF;
  RETURN NEW;
END $$;

-- Apply trigger
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger
                 WHERE tgname = 'legal_ticket_id_auto'
                 AND tgrelid = 'legal_escalation_tickets'::regclass) THEN
    CREATE TRIGGER legal_ticket_id_auto
      BEFORE INSERT ON legal_escalation_tickets
      FOR EACH ROW EXECUTE FUNCTION set_ticket_id_default();
  END IF;
END $$;

-- ✅ EXPERT RECOMMENDATION: Restore NOT NULL constraint after trigger is created
-- This prevents later UPDATE operations from setting ticket_id to NULL
ALTER TABLE legal_escalation_tickets
  ALTER COLUMN ticket_id SET NOT NULL;

-- =====================================================
-- Strengthen Column Types with ENUMs
-- =====================================================

-- Apply ENUMs to existing columns (with safe conversion)
-- First drop defaults to avoid casting issues
ALTER TABLE legal_escalation_tickets
  ALTER COLUMN status DROP DEFAULT,
  ALTER COLUMN priority DROP DEFAULT;

-- Convert to ENUM types
ALTER TABLE legal_escalation_tickets
  ALTER COLUMN status TYPE legal_ticket_status USING status::legal_ticket_status,
  ALTER COLUMN priority TYPE legal_ticket_priority USING priority::legal_ticket_priority,
  ALTER COLUMN violation_code TYPE violation_code_t USING violation_code::violation_code_t;

-- Restore defaults with ENUM values
ALTER TABLE legal_escalation_tickets
  ALTER COLUMN status SET DEFAULT 'open'::legal_ticket_status;

-- =====================================================
-- Audit Table Append-Only Protection (Expert Recommendation)
-- =====================================================

-- Make trust_safety_actions append-only for audit integrity
CREATE OR REPLACE FUNCTION prevent_trust_actions_mod()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF TG_OP IN ('UPDATE','DELETE') THEN
    RAISE EXCEPTION 'trust_safety_actions is append-only for audit integrity';
  END IF;
  RETURN NEW;
END $$;

-- Apply append-only protection
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger
                 WHERE tgname = 'trust_actions_append_only'
                 AND tgrelid = 'trust_safety_actions'::regclass) THEN
    CREATE TRIGGER trust_actions_append_only
      BEFORE UPDATE OR DELETE ON trust_safety_actions
      FOR EACH ROW EXECUTE FUNCTION prevent_trust_actions_mod();
  END IF;
END $$;

-- =====================================================
-- Auto-Maintain Timestamps (Expert Recommendation)
-- =====================================================

-- Add updated_at to trust_safety_actions for consistency
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'trust_safety_actions' AND column_name = 'updated_at') THEN
    ALTER TABLE trust_safety_actions ADD COLUMN updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW();
  END IF;
END $$;

-- Function to auto-update timestamps
CREATE OR REPLACE FUNCTION touch_updated_at()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END $$;

-- Apply to trust_safety_actions
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger
                 WHERE tgname = 'trust_actions_touch'
                 AND tgrelid = 'trust_safety_actions'::regclass) THEN
    CREATE TRIGGER trust_actions_touch
      BEFORE UPDATE ON trust_safety_actions
      FOR EACH ROW EXECUTE FUNCTION touch_updated_at();
  END IF;
END $$;

-- Auto-manage subscription pause timestamps
CREATE OR REPLACE FUNCTION set_pause_timestamps()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.pause_reason IS NOT NULL AND OLD.pause_reason IS DISTINCT FROM NEW.pause_reason THEN
    NEW.paused_at := COALESCE(NEW.paused_at, NOW());
  ELSIF NEW.pause_reason IS NULL THEN
    NEW.paused_at := NULL;
  END IF;
  RETURN NEW;
END $$;

-- Apply to billing_subscriptions table if it exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'billing_subscriptions') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_trigger
                   WHERE tgname = 'billing_subscriptions_pause_ts'
                   AND tgrelid = 'billing_subscriptions'::regclass) THEN
      CREATE TRIGGER billing_subscriptions_pause_ts
        BEFORE INSERT OR UPDATE ON billing_subscriptions
        FOR EACH ROW EXECUTE FUNCTION set_pause_timestamps();
    END IF;
  END IF;
END $$;

-- =====================================================
-- Row Level Security (RLS) Policies - FIXED
-- =====================================================

-- Enable RLS on legal escalation tickets (service_role access only)
ALTER TABLE legal_escalation_tickets ENABLE ROW LEVEL SECURITY;

-- SECURITY FIX: Use service_role only instead of wide-open authenticated access
DO $$
BEGIN
  -- Drop old wide-open policy if exists
  IF EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'legal_tickets_admin_access') THEN
    DROP POLICY legal_tickets_admin_access ON legal_escalation_tickets;
  END IF;

  -- Create secure service_role-only policy
  IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'legal_tickets_service_role') THEN
    CREATE POLICY legal_tickets_service_role ON legal_escalation_tickets
      FOR ALL
      TO service_role
      USING (true)
      WITH CHECK (true);
  END IF;
END $$;

-- Enable RLS on trust safety actions (service_role access only)
ALTER TABLE trust_safety_actions ENABLE ROW LEVEL SECURITY;

-- SECURITY FIX: Use service_role only instead of wide-open authenticated access
DO $$
BEGIN
  -- Drop old wide-open policy if exists
  IF EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'trust_actions_admin_access') THEN
    DROP POLICY trust_actions_admin_access ON trust_safety_actions;
  END IF;

  -- Create secure service_role-only policy
  IF NOT EXISTS (SELECT 1 FROM pg_policy WHERE polname = 'trust_actions_service_role') THEN
    CREATE POLICY trust_actions_service_role ON trust_safety_actions
      FOR ALL
      TO service_role
      USING (true)
      WITH CHECK (true);
  END IF;
END $$;

-- =====================================================
-- Trigger for updating legal ticket timestamps
-- =====================================================

CREATE OR REPLACE FUNCTION update_legal_ticket_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();

  -- Set resolved_at when status changes to resolved or closed
  IF NEW.status IN ('resolved', 'closed') AND OLD.status NOT IN ('resolved', 'closed') THEN
    NEW.resolved_at = NOW();
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger
                 WHERE tgname = 'legal_ticket_update_timestamp'
                 AND tgrelid = 'legal_escalation_tickets'::regclass) THEN
    CREATE TRIGGER legal_ticket_update_timestamp
      BEFORE UPDATE ON legal_escalation_tickets
      FOR EACH ROW
      EXECUTE FUNCTION update_legal_ticket_updated_at();
  END IF;
END $$;

-- ✅ EXPERT RECOMMENDATION: Removed session_replication_role reset
-- No longer needed since we're not using replica mode

COMMIT;

-- =====================================================
-- Migration Verification
-- =====================================================

-- Verify tables were created
DO $$
BEGIN
  -- Check legal_escalation_tickets
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'legal_escalation_tickets') THEN
    RAISE EXCEPTION 'Migration failed: legal_escalation_tickets table not created';
  END IF;

  -- Check trust_safety_actions
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'trust_safety_actions') THEN
    RAISE EXCEPTION 'Migration failed: trust_safety_actions table not created';
  END IF;

  -- Check user_admin_status payment blocking fields
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                 WHERE table_name = 'user_admin_status' AND column_name = 'payments_blocked') THEN
    RAISE EXCEPTION 'Migration failed: user_admin_status.payments_blocked column not added';
  END IF;

  RAISE NOTICE '✅ Trust & Safety Legal Escalation migration completed successfully';
END $$;