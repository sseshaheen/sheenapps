/**
 * Recommendations Lifecycle Store
 *
 * Manages the recommendations state machine with two sources:
 * 1. Quick Suggestions - Generated instantly from prompt analysis (client-side)
 * 2. AI Recommendations - Generated by the server (takes time)
 *
 * State Flow:
 * - Build starts → Show quick suggestions immediately (status: 'ready', readySource: 'quick')
 * - AI generation starts → aiGenerationStarted: true (show "personalizing..." indicator)
 * - AI recs ready → aiReady: true (show "personalized suggestions ready" button)
 * - User clicks → readySource: 'ai' (swap to AI recommendations)
 * - AI fails → aiFailed: true (show fallback message, keep showing quick suggestions)
 *
 * SSE Integration:
 * - SSE sends signal-only events (recommendations_ready, recommendations_failed)
 * - Client fetches actual recommendations from DB (source of truth)
 * - This store tracks lifecycle state, React Query handles data fetching
 */

'use client'

import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { logger } from '@/utils/logger'
import type { ProjectRecommendation } from '@/types/project-recommendations'

/**
 * Status of the recommendations system.
 */
export type RecommendationsStatus = 'idle' | 'pending' | 'ready' | 'failed'

/**
 * Which source is currently being displayed.
 */
export type ReadySource = 'quick' | 'ai'

/**
 * Quick suggestion from prompt analysis.
 * Uses i18n keys for localization - actual text is rendered in components.
 */
export interface QuickSuggestion {
  id: string
  titleKey: string      // i18n key for title
  descriptionKey: string // i18n key for description
  category: string
  promptKey: string     // i18n key for the action prompt
}

/**
 * Prompt analysis data used to generate quick suggestions.
 * This comes from the AI's analysis of the user's prompt.
 */
export interface PromptAnalysis {
  businessType: string
  confidence: number
  extractedInfo: {
    services: string[]
    personality: string[]
    targetAudience: string[]
    functionalRequirements: string[]
  }
  missingInformation: string[]
}

interface RecommendationsState {
  /** Current status of the recommendations system */
  status: RecommendationsStatus
  /** Which source is currently being displayed (quick or AI) */
  readySource: ReadySource | null
  /** Whether AI recommendations have arrived on server (even if not shown yet) */
  aiReady: boolean
  /** Whether AI generation failed (distinct from aiReady: false) */
  aiFailed: boolean
  /** Track if AI generation is in progress (for "personalizing..." UX) */
  aiGenerationStarted: boolean
  /** Quick suggestions generated from prompt analysis */
  quickSuggestions: QuickSuggestion[] | null
  /** AI-generated recommendations from server */
  recommendations: ProjectRecommendation[] | null
  /** Error message if failed */
  error: string | null
  /** Build session ID this is associated with */
  buildSessionId: string | null
}

interface RecommendationsActions {
  /**
   * Called when build starts. Immediately shows quick suggestions.
   * @param buildSessionId - The build session ID
   * @param quickSuggestions - Pre-generated quick suggestions from prompt analysis
   */
  startBuildSession: (buildSessionId: string, quickSuggestions: QuickSuggestion[]) => void

  /**
   * Called when SSE notifies AI recs are ready on server.
   * This triggers the UI to fetch from DB and show "personalized ready" indicator.
   */
  notifyAiRecsReady: () => void

  /**
   * Called after fetching recommendations from DB.
   * Stores the recs but does NOT auto-switch display (user might be reading quick suggestions).
   */
  setAIRecommendations: (recs: ProjectRecommendation[]) => void

  /**
   * Called when user clicks "show personalized" - switches display source.
   */
  switchToAIRecommendations: () => void

  /**
   * Called when AI generation fails.
   * If we have quick suggestions, we keep showing them with a fallback message.
   */
  setFailed: (error: string) => void

  /**
   * Reset on new build or when leaving the builder.
   */
  reset: () => void

  /**
   * Get current state summary for debugging.
   */
  getStateSummary: () => {
    status: RecommendationsStatus
    readySource: ReadySource | null
    aiReady: boolean
    aiFailed: boolean
    hasQuickSuggestions: boolean
    hasAIRecommendations: boolean
  }
}

type RecommendationsStore = RecommendationsState & RecommendationsActions

const initialState: RecommendationsState = {
  status: 'idle',
  readySource: null,
  aiReady: false,
  aiFailed: false,
  aiGenerationStarted: false,
  quickSuggestions: null,
  recommendations: null,
  error: null,
  buildSessionId: null,
}

export const useRecommendationsStore = create<RecommendationsStore>()(
  devtools(
    (set, get) => ({
      ...initialState,

      startBuildSession: (buildSessionId: string, quickSuggestions: QuickSuggestion[]) => {
        logger.info('recommendations', `Starting session ${buildSessionId.slice(0, 20)} with ${quickSuggestions.length} quick suggestions`)

        set({
          status: 'ready',  // Immediately ready with quick suggestions
          readySource: 'quick',
          aiReady: false,
          aiFailed: false,  // Reset on new build
          aiGenerationStarted: true,  // AI generation has started
          quickSuggestions,
          recommendations: null,
          error: null,
          buildSessionId,
        })
      },

      notifyAiRecsReady: () => {
        const current = get()
        logger.info('recommendations', `AI recs ready for session ${current.buildSessionId?.slice(0, 20)}`)

        // SSE notification received - AI recs are ready on server
        // UI should fetch from DB
        set({
          aiReady: true,           // Recs are ready on server
          aiGenerationStarted: false,  // Generation complete
        })
      },

      setAIRecommendations: (recs: ProjectRecommendation[]) => {
        logger.info('recommendations', `Received ${recs.length} AI recommendations`)

        // Store the recs but DON'T auto-switch display
        // User might be reading quick suggestions
        set({
          recommendations: recs,
          aiReady: true,
          aiGenerationStarted: false,
          // Keep readySource as-is - user decides when to switch
        })
      },

      switchToAIRecommendations: () => {
        const { recommendations } = get()
        if (!recommendations) {
          logger.warn('recommendations', 'Cannot switch to AI recs - not loaded yet')
          return
        }

        logger.info('recommendations', 'Switching display to AI recommendations')
        set({ readySource: 'ai' })
      },

      setFailed: (error: string) => {
        const current = get()
        logger.error('recommendations', `AI recs failed: ${error}`)

        // Only set status: 'failed' if we don't have quick suggestions to fall back to
        if (!current.quickSuggestions) {
          set({
            status: 'failed',
            error,
            aiFailed: true,
            aiGenerationStarted: false
          })
        } else {
          // Keep showing quick suggestions, but mark AI as failed
          // UI can show "personalized suggestions unavailable" message
          set({
            aiReady: false,
            aiFailed: true,
            error,
            aiGenerationStarted: false
          })
        }
      },

      reset: () => {
        logger.info('recommendations', 'Resetting recommendations store')
        set(initialState)
      },

      getStateSummary: () => {
        const state = get()
        return {
          status: state.status,
          readySource: state.readySource,
          aiReady: state.aiReady,
          aiFailed: state.aiFailed,
          hasQuickSuggestions: !!state.quickSuggestions && state.quickSuggestions.length > 0,
          hasAIRecommendations: !!state.recommendations && state.recommendations.length > 0,
        }
      }
    }),
    {
      name: 'recommendations-store',
      enabled: process.env.NODE_ENV === 'development'
    }
  )
)

// Selectors for common use cases

/**
 * Get the current recommendations status.
 */
export function useRecommendationsStatus(): RecommendationsStatus {
  return useRecommendationsStore(state => state.status)
}

/**
 * Get the current display source (quick or AI).
 */
export function useRecommendationsReadySource(): ReadySource | null {
  return useRecommendationsStore(state => state.readySource)
}

/**
 * Check if AI recommendations are ready (even if not displayed).
 */
export function useAIRecsReady(): boolean {
  return useRecommendationsStore(state => state.aiReady)
}

/**
 * Check if AI generation is in progress.
 */
export function useAIGenerationInProgress(): boolean {
  return useRecommendationsStore(state => state.aiGenerationStarted)
}

/**
 * Check if AI generation failed.
 */
export function useAIRecsFailed(): boolean {
  return useRecommendationsStore(state => state.aiFailed)
}

/**
 * Get quick suggestions.
 */
export function useQuickSuggestions(): QuickSuggestion[] | null {
  return useRecommendationsStore(state => state.quickSuggestions)
}

/**
 * Get AI recommendations.
 */
export function useAIRecommendations(): ProjectRecommendation[] | null {
  return useRecommendationsStore(state => state.recommendations)
}

/**
 * Get the currently displayed recommendations/suggestions.
 * Returns quick suggestions if readySource is 'quick', AI recs if 'ai'.
 */
export function useDisplayedRecommendations(): (QuickSuggestion | ProjectRecommendation)[] | null {
  return useRecommendationsStore(state => {
    if (state.readySource === 'ai') {
      return state.recommendations
    }
    return state.quickSuggestions
  })
}

/**
 * Get the build session ID for current recommendations.
 */
export function useRecommendationsBuildSessionId(): string | null {
  return useRecommendationsStore(state => state.buildSessionId)
}

/**
 * Get actions without subscribing to state changes.
 */
export function useRecommendationsActions() {
  return useRecommendationsStore(state => ({
    startBuildSession: state.startBuildSession,
    notifyAiRecsReady: state.notifyAiRecsReady,
    setAIRecommendations: state.setAIRecommendations,
    switchToAIRecommendations: state.switchToAIRecommendations,
    setFailed: state.setFailed,
    reset: state.reset,
  }))
}

// Expose for testing
if (typeof window !== 'undefined' && (process.env.NODE_ENV === 'test' || process.env.NEXT_PUBLIC_ENABLE_TEST_HOOKS === 'true')) {
  (window as unknown as { __RECOMMENDATIONS_STORE__: typeof useRecommendationsStore }).__RECOMMENDATIONS_STORE__ = useRecommendationsStore
}
